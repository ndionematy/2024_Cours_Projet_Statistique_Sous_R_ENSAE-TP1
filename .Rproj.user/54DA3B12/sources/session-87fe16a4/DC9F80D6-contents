---
title: "TPA - Juste pour essayer"
author: "Maty NDIONE"
date: "`r Sys.Date()`"
output: word_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Importation des donnees

```{r}
library(haven)
ma_base <- read_dta("D:\\ISE1 docs\\2ndSemestre\\ProjetStatistiqueSurR\\Cours\\Donnees\\Fichiers_Traitement&AnalysePauvrete\\ehcvm_menage_SEN2018.dta")
View(ma_base)
```

NB: %\>% se lit **pipe**. Elle permet d'appliquer une fonction à un objet. Il existe aussi un équivalent de pip noté: **\|\>**

# Manipulation de variables

## Selection (select)

1.  Selectionner par indice base %\>% select(c(2,p,n))
2.  Selectionner par nom base %\>% select(c("Variable 1","Variable 1","Variable 1"))
3.  Selectionner par caracteres
    -   Nom de la variable contient *revenu* : **base *%\>%* select(contains("revenu"))**
    -   Nom de la variable commence par *menage* : **base *%\>%* select(starts_with("menage"))**
    -   Nom de la variable se termine par *menage* : **base *%\>%* select(ends_with("menage"))**
4.  Selectionner par type\
    **base *%\>%* selectif(is.numeric)**\
    **base *%\>%* selectif(is.charater)**\

## Filtre (filter)

1.  Si la valeur pour une variable est inférieure à 10 : **base *%\>%* filter(nom_variable\<10)**\
2.  Si la valeur pour une variable est égale à 5, 8, 10 : **base *%\>%* filter(nom_variable%in%c(5, 8, 10))**\
    Si la valeur pour une variable est une chaine : **base *%\>%* filter(nom_variable%in%c("Superieur", "Primaire"))**\
    NB: Il est possible d'insérer des opérateurs logiques sur les filtres (ou:\|, et:&)\
3.  Si la valeur pour une variable est différente d'une certaine valeur p : **base *%\>%* filter(nom_variable!=p)**\

## Création de variables (mutate)

new_base %\>% mutate(new_var=var1+var2)\
new_base %\>% mutate(new_var=mean(var1))\
Il existe également les fonctions mutate_if, mutate_at, mutate_all.\
Il est également possible d'appliquer une fonction(somme, moyenne) pour un ensemble de variables, on utilise mutate(accross) pour éviter la fonction mutate plusieurs fois. Elle surtout utile pour les QCM. La syntaxe est la suivante: **new_base *%\>%* mutate(across( variables,~sum(., na.rm=TRUE)))**

```{r}
vars = c("grosrum","petitrum","porc","lapin","volail")
#ma_base %>% mutate(across(vars,~sum(., na.rm = TRUE)))
```

## Nommer une variable

Pour renommer une variable, on utilise la fonction rename: **rename(new_var=old_var)**

```{r}
ma_base %>% rename(tele=tv)
```

## Labélisation

Labéliser une variable c'est lui donner une description. Pour ce faire, on utilise le package *expss*

```{r}
library(expss)
ma_base = ma_base %>% expss::apply_labels(elec_ac="Acces au reseau electrique",
                                         elec_ur="Utilise le reseau electrique",
                                         elec_ua="Utilise le reseau solaire")
```

## Recodage
```{r echo=FALSE}
library(dplyr)
library(expss)
```

```{r}
char_vec = sample(c("a","b","c"), 10, replace=TRUE)
char_vec
dplyr::recode(char_vec, a="Apple", b="Banana", c="Cherry")
```

```{r}
# Change les valeurs SEN de la variable country en SN
# Elle permet aussi de partir d'une variable de type numérique en caractère
dplyr::recode(ma_base$country, SEN="SN")
# Pour donner un sens à la variable numérique (coder les variables), on utilise recode factor
```

```{r}
num_vec = c(1:4, NA)
dplyr::recode_factor(num_vec,
              '1' = "Primaire",
              '2' = "Secondaire",
              '3' = "Tertiaire",
              .missing = "Missing",
              .default = "NAN")
num_vec 

num_vec1 = as.numeric(num_vec)
num_vec1
```

```{r}
# Afficher la base avec les labels
ma_base = ma_base %>% labelled::to_factor() 
```

```{r}
ma_base$sol = dplyr::recode(ma_base$sol, Oui="0", Non="1") 
```

```{r}
recode_factor(ma_base$sol,
                     '0' = "YES",
                     '1' = "NO")
```



